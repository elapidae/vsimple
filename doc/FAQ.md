# FAQ

List of common questions with answers.

---

⌦ **Почему надо тянуть всю *vsimple*, если мне из нее надо только маленький кусочек?**

Сама *vsimples* есть некоторый аналог *coreutils*, только для плюсов. Это есть набор микроинструментов, которые применяются от проекта к проекту. Притом в каждом проекте могут применяться 5-10% из всего что в *vsimples* находится. Дело в том, что эти %% для каждого проекта РАЗНЫЕ. Есть микрухи, которые используются в каждом проекте. Вот, нажал menu->new project, сразу подключил *vsimples->vlog*, сразу пишу в *main()* ```vdebug << "Hello world!```. Да, кстати, никто не жалуется, зачем ему, например, весь *STL*, если нужен только *std::vector*...

---

⌦ **Я хочу использовать только свои 10%, остальное мне НЕ НУЖНО!**

Не подключай остальное к проекту. Оно не попадет в сборку. Можно только пенять на занятое место, учитывая вес *vsimples*, даже не смешно. Преимущества автоподключения -- подключается ТОЛЬКО нужные микрухи. В случае с библиотекой такое не прокатит: либо вот тебе всю, либо иди гуляй.

---

⌦ **А давай разобьем эти микрухи на отдельные кусочки (микрорепозитории?).**

Вся прелесть этих микрух, что они могут использовать друг друга. **.cmake и *.pri* файлики устроены таким образом, чтобы части, которые используют другие микрухи подцепляли их автоматически. Если их разложить "далеко" друг от друга, то их стыковка будет сложнее для конечного программиста. Например, базовая часть vlog использует специальный интерфейс (*vcat_iface*), входящий в отдельную микруху (*vcat*). Кроме него этот интерфейс еще используется двумя другими микрухами. Соотв. если добавить к этому интерфейсу какой-нибудь метод (например, модификатор потока), то его сразу же получат все три компонента. Преимущества можно оценить поработав с такой системой микросервисов.

Ничего более удобного автор близко ни в какой другой системе сборки для *C++* не видел.

---

⌦ **Что значит подключают другие микросервисы автоматически?**

Микросервисы привязывают себя к системе сборки через переменную *VSIMPLE_DIR*, соответственно, они могут подключать нужные им другие компоненты рекурсивно. Притом, зависимости сразу видны (по крайней мере, в QtCreator). Таким образом, сразу видна архитектура и зависимости. Проекты, без зависимостей находятся на "нулевом этаже" и зависят только от стандартной библиотеки, использующие такие компоненты оказываются на "первом этаже" и т.д. Иерархия применения компонент выстраивается автоматически, циклические зависимости сразу же фиксируются сборкой. Есть компоненты-обертки к подключению системных библиотек. В их задачу, в т.ч. входит мягкое "всасывание" в проект библиотеки, настройка путей к заголовкам, включение *pkg-config*-а и пр. В общем, помощь в использовании библиотеки.

Опять же, сразу видно какие библиотеки используются.

---

⌦ ****

Ну ладно, пусть лежат, но мне не нравиться, что оно собирается каждый раз с новым проектом, я хочу чтобы это было библиотека!

Нажимаем "*new project -> library*", подключаем все микрухи, собираем БИБЛИОТЕКУ! Ну правда, когда есть исходники, собрать библиотеку можно, обратное не верно.

Речь о заботе о конечном пользователе. Проследим путь работы с библиотекой:

1. скачать (```git clone ssh://green_wolf.com/git```);
2. насторить и скомпилировать (```./configure, make```);
3. зас*ать собственную систему из под рута (```sudo make install```, для умных: ```sudo checkinstall```);
4. подключить к проекту (в *.pro* ```LIBS += -lgreen_wolf -L/opt/green_wolf/lib```, в *cmake*: ```REQUIRED...```, притом, надо, чтобы библиотека себя еще и подготовила для *REQUIRED*). Настроить пути, если не стандартны. Если библиотека требует,  использовать *pkg-config* и прочие радости.

При том, каждый библиотекописарь сам себе агроном и творит такое, что подключение библиотеки может превратиться в длииииннное приключение (Кстати, именно поэтому, библиотеки тоже подключаются через механизм *vsimples*. Один раз на***ся, перелопатил пол инета, зато потом можно забыть как страшный сон).

Т.е. имеем цикл:

```    
{   
	git clone ->
       configure ->
       make ->
       sudo install ->
       // должна быть фиксация версии в проекте, но ее нету...
}
```

Что предлагается:

```
{
	git ->
       фиксация в проекте.
}
```

Где простота и надежность -- решать вам...

При изменении библиотеки, все с самого начала. Хотим поменять флаг компиляции библиотеки ... ну ты понел? Далее -- имеем несовместимые версии библиотек на разных машинах (Сталкивались с этим? А автор стакивался, когда разобрался, к компу неделю не подходил). Это потому что используемые библиотеки не зафиксированы с исходниках.

В случае использования механизма *vsimples*, имеем две ОЧЕВИДНЫЕ строчки для подключения нужного компонента, остальные тихо-мирно лежат рядышком, ждут своей очереди. Подключаем субрепом -- никаких проблем с запуском на других машинах.

Есть еще ряд преимуществ, не сразу видных со стороны. Например, если собираемся из исходников, то помогаем компилятору с оптимизацией.

Про внешние библиотеки речи нету, здесь никак не помочь, с ними весь этот АДъ. Речь о том, что, хотя бы, наш код будет под контролем *git*.

---

⌦ ****

---