//=======================================================================================
UPD 2019-09-19
elapidae: переименован класс VGit в vgit. Удобнее стало.
//=======================================================================================
vgit "всасывает" в сборку сведения о последнем коммите в папке проекта.

//=======================================================================================
Для qmake необходимо определить переменную MAIN_DIR:
VLIBS_DIR = ...... где это хозяйство лежит
...
MAIN_DIR = $$PWD
include( $$VLIBS_DIR/qmake/vgit.pri )

//=======================================================================================
Для cmake можно переменную MAIN_DIR не определять, тогда она автоматически
инициализируется значением ${CMAKE_SOURCE_DIR}.
Зато после add_executable(...) следует включить еще vgit_post.cmake. Это нужно, чтобы
при изменении текущего коммита, cmake пересобирал информацию о нем.


set ( VLIBS_DIR ......где это хозяйство лежит )
...
# set ( MAIN_DIR ${CMAKE_SOURCE_DIR} ) -- можно не делать...
include( "$VLIBS_DIR/cmake/vgit.cmake" )
...
add_executable( ${PROJECT_NAME} "main.cpp" ${V_SOURCES} ${V_HEADERS} )

include( "${VLIBS_DIR}/cmake/vgit_post.cmake" ) # NB! НЕ ЗАБУДЬТЕ!!!!
unset ( QT_QMAKE_EXECUTABLE )
//=======================================================================================

//=======================================================================================
В коде можно использовать примерно так:

#include <iostream>
#include "vgit.h"

using std::cout;
using std::endl;

int main( int argc, char **argv )
{
    //  Если в аргументах есть что-нибудь, начинающееся на --vgit, то: если указан один
    //  из флагов --vgit-branch, --vgit-hash, --vgit-revcount, --vgit-date, vgit-author,
    //  печатает конкретный параметр (для автосборки информации, например)
    //  Если же будет --vgit-чегонибудькривое, то распечатает все показатели.
    //  Если чего-нибудь напечатал, то выходит по exit(retcode).
    //  retcode необязателен, по умолчанию равен 0.
    int retcode = 42;
    vgit::print_and_exit_if_need( argc, argv, retcode );

    //  Все вместе.
    cout << vgit::as_message()  << std::endl;

    cout << vgit::hash()        << endl;
    cout << vgit::revcount()    << endl;
    cout << vgit::branch()      << endl;
    cout << vgit::author()      << endl;
    cout << vgit::date()        << endl;

    // Метка времени компиляции.
    // К git отношения не имеет, но здесь вполне уместно...
    cout << vgit::compile_datetime() << std::endl;

    return 0;
}
//=======================================================================================

//=======================================================================================
Принцип действия -- нужная информация собирается в переменные сборки выполнением команд:

git log -n 1 --pretty=format:"%H"
git rev-list HEAD --count
git symbolic-ref --short HEAD
git log -n 1 --pretty=format:"%an"
git log -n 1 --pretty=format:"%aI"

Далее, устанавливаются макросы в строку сборки компилятора (флагами -DMACRONAME=VALUE).
В vgit.cpp они преобразуются в соответствующие литералы и предоставляются уже в
нормальных строках.


Примечание: если на репе будет "оторванная голова" (DETACHED HEAD), команда 
"git symbolic-ref --short HEAD" выдаст ошибку и имя ветки сграблено не будет.

Сейчас в такой ситуации vgit::branch() возвращает "DETACHED HEAD", но не рассчитывайте на
такое поведение.
//---------------------------------------------------------------------------------------
Есть еще одна сложность: в случае commit|checkout репозитория, система сборки об этом не
догадывается, т.к. исходники при этом могут не изменится.

Для qmake проблема решается топорно, жестко и надежно: в QMAKE_POST_LINK добавляются
команды удаления файлов, в которые прошиваются наши макросы -- vgit.o, main.o, Makefile.
Получается, что при следующей компиляции, qmake будет вынужден их пересобрать.
Работает как часы, чуть увеличивает время компиляции, особо не заметно.

Для cmake, как уже было сказано выше, ситуация другая. Для него пока не было найдено 100%
решения, очень бы хотелось такое найти. При постудалении объектников он впадает в ошибку.
Решение следующее -- делается цель сборки на изменение ${CMAKE_SOURCE_DIR}/.git/HEAD.
Простенько и со вкусом.
НО! К СОЖАЛЕНИЮ! Работает только со второй сборки после изменения репа :(((.
Решения на первую сборку пока не найдено...
//=======================================================================================

