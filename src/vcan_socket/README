//=======================================================================================

can.txt взят отсюда:
https://www.kernel.org/doc/Documentation/networking/can.txt

//=======================================================================================

По первичной настроке, в т.ч. виртуальной шины
https://ru.qwe.wiki/wiki/SocketCAN

Существует также виртуальный драйвер CAN для целей тестирования, которые могут быть
загружены и созданные в Linux с указанными ниже командами.

$ modprobe can
$ modprobe can_raw
$ modprobe vcan
$ sudo ip link add dev vcan0 type vcan
$ sudo ip link set up vcan0
$ ip link show vcan0
3: vcan0: <NOARP,UP,LOWER_UP> mtu 16 qdisc noqueue state UNKNOWN
    link/can

//=======================================================================================

На 2020-04-09
В тесте на пару секунд запускается прослушка шины vcan0.
Если в консоли перед запуском теста включить cangen vcan0, то должны приходить
тестовые сообщения, которые будут напечатаны в консоли.

//=======================================================================================

На 2020-05-13
Дима Попов запилил получение точной метки времени получения CAN сообщений через ioctl.
Соответственно, решил, таки, вводить систематизацию impl_vposix/wrap_ioctl.
Этот вызов перенесен туда.
Хотел, чтобы send возвращал метку отправки пакета, провел эксперименты, при отправке
забрать время через SIOCGSTAMP не получится, т.е. получить время отправки нет
возможности, что, по размышлении, вполне логично. Что на шине творится нас не касается.


Подкорректировал send_raw, чтобы он проверял что всё отправлено. Было так, что сырые
данные могли уйти не все.

Добавил в папку с тестами скрипт 'turn-on-vcan0-need-root.sh', запускающий vcan0.

//=======================================================================================
